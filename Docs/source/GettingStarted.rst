.. highlight:: rst

Obtaining, building and running `PeleLM`
========================================

Obtaining `PeleLM`
^^^^^^^^^^^^^^^^^^

First, make sure that "git" is installed on your machine---we recommend version 1.7.x or higher.

1. Download the `AMReX` repository by typing: ::

    git clone https://github.com/AMReX-Codes/amrex.git


This will create a folder called ``amrex/`` on your machine. Set the environment variable, ``AMREX_HOME``, on your
machine to point to the path name where you have put `AMReX`. You can add this to your ``.bashrc`` as::

    export AMREX_HOME=/path/to/amrex/

2. Download the `IAMR` repository by typing: ::

    git clone https://github.com/AMReX-Codes/IAMR.git

This will create a folder called ``IAMR/`` on your machine.
Set the environment variable, ``IAMR_HOME``.

3. Obtain an ORNL GitLab account and clone the `Pele` repositories: ::

    git clone https://<username>@code.ornl.gov/Pele/PeleLM.git
    git clone https://<username>@code.ornl.gov/Pele/PelePhysics.git

This will create folders called ``PeleLM/`` and ``PelePhysics/`` on your machine.
Set the environment variables, ``PELELM\_HOME`` and ``PELE_PHYSICS_HOME``.

4. You will want to periodically update each of these repositories
by typing ``git pull`` within each repository.


Building `PeleLM`
^^^^^^^^^^^^^^^^^

The `PelePhysics` repository contains chemistry models and the encapsulating source 
code that is used by `PeleLM` and `PeleC` (the compressible combustion solver).  More
information on the source and data files for the chemistry models is coming soon.

In `PeleLM` each different problem setup is stored in its own
sub-folder under ``PeleLM/Exec/``, and a local version of the 
`PeleLM` executable is built directly in that folder (object libraries are not used to manage the `AMReX`
and application code).  The name of the executable (generated by the make
system) encodes several of the build characteristics, including dimensionality of the problem,
compiler name, and whether `MPI` and/or `OpenMP` were linked with the executable.
Thus, several different build configurations may coexist simultaneously in a problem folder.

The build system is based on GNU make and is relatively self-contained.  We have accumulated 
specialized building setups over the years for a wide variety of hardware configurations, and 
the system is quite easy to modify to add new machine/OS/compiler types and site-specific 
options (optimizations, cross-compiles, user-maintained includes, module-based strategies, etc).
The system currently supports a wide range of Linux, OSX, Windows (via CYGWIN), AIX and BGL 
configurations. With some luck, your machine will be supported out of the box -- however, if 
you run into problems and need assistance building on your hardware, contact `Marc Day <MSDay@lbl.gov_>`_.

In the following, we step through building a representative `PeleLM` executable.

1. We will work in the folder containing setup for the `FlameInABox` problem in 2-d and 3-d
(``PeleLM/Exec/FlameInABox``.
In this setup, cold fuel enters the domain bottom and passes through a flame sheet.
Hot products exit the domain at the top.  The sides of the domain are periodic, and the coordinates are
cartesian. From the folder in which you checked out the `PeleLM` git repo, type::

cd PeleLM/Exec/FlameInABox

2. In ``FlameInABox/``, edit the ``GNUmakefile``, and set::

    DIM = 2
    COMP = gnu (or your favorite C++/F90 compiler suite)
    DEBUG = TRUE
    USE_MPI = TRUE
    USE_OMP = FALSE

If you want to try compilers other than those in the GNU suite, and you find that they don't
work, please let us know.

To build a serial (single-processor) code, set ``USE_MPI = FALSE``.
This will compile the code without the `MPI` library.  If you want to do
a parallel run, set ``USE_MPI = TRUE``.  In this
case, the build system will need to know about your `MPI` installation.
This can be done by editing the makefiles in the `AMReX` tree.
Set ``DEBUG=FALSE`` in order to create an optimized version for production runs.

The resulting executable will look something like ``PeleLM2d.gnu.MPI.ex``,
suggesting that this is a 2D version of the code, made with 
``COMP=gnu`` and ``USE_MPI=TRUE``.

Running `PeleLM`
^^^^^^^^^^^^^^^^

1. `PeleLM` takes an input file as its first command-line argument.  The file may
contain a set of parameter definitions that will overrides defaults set in the code.
To run `PeleLM` with an example inputs file, type::

    ./PeleLM2d.gnu.MPI.ex inputs.2d-regt

2. `PeleLM` typically generates subfolders in the current folder that are named ``plt00000/``, ``plt00020/``, etc, and ``chk00000/``, ``chk00020/``, etc. These are "plotfiles" and "checkpoint" files. The plotfiles are used for visualization of derived fields; the checkpoint files are used for restarting the code.


The output folders contain a collection of ASCII and binary files.  The field data is generally written in a self-describing binary format; the ASCII header files provide additional metadata to give AMR context to the field data.


Visualization of the results
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are several options for visualizing the data.  The popular
`Vis-It` package supports the `AMReX` file format natively, as does
the `yt` python package.  The standard tool used within the
`AMReX`-community is `Amrvis`, a package developed and supported 
by CCSE that is designed specifically for highly efficient visualization
of block-structured hierarchical AMR data, however there are limited visualization
tools available in `Amrvis`, so most users make use of multiple tools depending on their needs.

For more information on how to use `Amrvis` and `VisIt`, refer to the `AMReX`
User's guide in the `AMReX` git repository for download/build/usage instructions.

